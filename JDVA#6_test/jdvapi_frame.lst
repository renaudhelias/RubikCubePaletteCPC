                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.6.0 #9615 (MINGW32)
                              4 ;--------------------------------------------------------
                              5 	.module jdvapi_frame
                              6 	.optsdcc -mz80
                              7 	
                              8 ;--------------------------------------------------------
                              9 ; Public variables in this module
                             10 ;--------------------------------------------------------
                             11 	.globl _precalc_vram
                             12 	.globl _erase_frame
                             13 	.globl _put_frame_transparent
                             14 	.globl _put_frame
                             15 	.globl _private_precalc_vram
                             16 ;--------------------------------------------------------
                             17 ; special function registers
                             18 ;--------------------------------------------------------
                             19 ;--------------------------------------------------------
                             20 ; ram data
                             21 ;--------------------------------------------------------
                             22 	.area _DATA
   0000                      23 _private_precalc_vram::
   0000                      24 	.ds 400
                             25 ;--------------------------------------------------------
                             26 ; ram data
                             27 ;--------------------------------------------------------
                             28 	.area _INITIALIZED
                             29 ;--------------------------------------------------------
                             30 ; absolute external ram data
                             31 ;--------------------------------------------------------
                             32 	.area _DABS (ABS)
                             33 ;--------------------------------------------------------
                             34 ; global & static initialisations
                             35 ;--------------------------------------------------------
                             36 	.area _HOME
                             37 	.area _GSINIT
                             38 	.area _GSFINAL
                             39 	.area _GSINIT
                             40 ;--------------------------------------------------------
                             41 ; Home
                             42 ;--------------------------------------------------------
                             43 	.area _HOME
                             44 	.area _HOME
                             45 ;--------------------------------------------------------
                             46 ; code
                             47 ;--------------------------------------------------------
                             48 	.area _CODE
                             49 ;jdvapi_frame.c:2: void put_frame(unsigned char *pAddress, unsigned char nWidth, unsigned char nHeight, const unsigned char *image)
                             50 ;	---------------------------------
                             51 ; Function put_frame
                             52 ; ---------------------------------
   0000                      53 _put_frame::
   0000 DD E5         [15]   54 	push	ix
   0002 DD 21 00 00   [14]   55 	ld	ix,#0
   0006 DD 39         [15]   56 	add	ix,sp
                             57 ;jdvapi_frame.c:34: __endasm;
   0008 DD 6E 04      [19]   58 	LD	L, 4(IX) ; HL --> Adr destination
   000B DD 66 05      [19]   59 	LD	H, 5(IX)
   000E DD 4E 06      [19]   60 	LD	C, 6(IX) ; C --> Largeur en octet
   0011 DD 46 07      [19]   61 	LD	B, 7(IX) ; B --> Hauteur
   0014 DD 5E 08      [19]   62 	LD	E, 8(IX) ; DE --> Adresse image source.
   0017 DD 56 09      [19]   63 	LD	D, 9(IX)
   001A                      64 	    _loop_alto000:
   001A C5            [11]   65 	PUSH	BC ; Sauvegarde de BC sur la pile (width et height)
   001B 41            [ 4]   66 	LD	B,C ; Charge C (width) dans B
   001C E5            [11]   67 	PUSH	HL ; Sauvegarde de HL (adresse de la destination)
   001D                      68 	    _loop_ancho000:
   001D 1A            [ 7]   69 	LD	A,(DE) ; Met dans A un octet de de la source
   001E 77            [ 7]   70 	LD	(HL),A ; Met dans la destination A
   001F 13            [ 6]   71 	INC	DE ; Avance dans l'adresse de la source
   0020 23            [ 6]   72 	INC	HL ; Avance dans l'adresse de la destination
   0021 10 FA         [13]   73 	DJNZ	_loop_ancho000 ; Décrémente B qui contient la largeur. Si on à pas finit de copier
                             74 ;	l'équivalent de la largeur on saute à _loop_ancho.
   0023 E1            [10]   75 	POP	HL ; récupère l'adresse de la cible sauvegardé sur la pile
   0024 7C            [ 4]   76 	LD	A,H ; Charge la partie haute dans A
   0025 C6 08         [ 7]   77 	ADD	#0x08 ; Ajoute la valeur 8 à A --> Permet de passer à la ligne suivante
   0027 67            [ 4]   78 	LD	H,A ; Réinjecte A dans H, HL nous donne ainsi l'adresse de début de la ligne suivante
   0028 D6 C0         [ 7]   79 	SUB	#0xC0 ; On vérifie que la ligne suivante en mémoire n'est pas à remonter ... 
   002A D2r31r00      [10]   80 	JP	NC, _sig_linea000 ; Non, elle est à la suite en mémoire donc tout va bien
   002D 01 50 C0      [10]   81 	LD	BC, #0xC050 ; On doit remonter, on va ajouter C000 (notre page par défaut + 0x080 pour la ligne suivante)
   0030 09            [11]   82 	ADD	HL,BC ; Ajoute ça dans l'adresse de destination --> On est sur la nouvelle ligne
   0031                      83 	    _sig_linea000:
   0031 C1            [10]   84 	POP	BC ; Récupère BC --> pour récupérer la hauteur
   0032 10 E6         [13]   85 	DJNZ	_loop_alto000 ; Enlève 1 à la hauteur, si on à pas tout traité, on reboucle au début _loop_alto
   0034 DD E1         [14]   86 	pop	ix
   0036 C9            [10]   87 	ret
                             88 ;jdvapi_frame.c:37: void put_frame_transparent(unsigned char *pAddress, unsigned char nWidth, unsigned char nHeight, const unsigned char *image)
                             89 ;	---------------------------------
                             90 ; Function put_frame_transparent
                             91 ; ---------------------------------
   0037                      92 _put_frame_transparent::
   0037 DD E5         [15]   93 	push	ix
   0039 DD 21 00 00   [14]   94 	ld	ix,#0
   003D DD 39         [15]   95 	add	ix,sp
                             96 ;jdvapi_frame.c:70: __endasm;
   003F DD 6E 04      [19]   97 	LD	L, 4(IX) ; HL --> Adr destination
   0042 DD 66 05      [19]   98 	LD	H, 5(IX)
   0045 DD 4E 06      [19]   99 	LD	C, 6(IX) ; C --> Largeur en octet
   0048 DD 46 07      [19]  100 	LD	B, 7(IX) ; B --> Hauteur
   004B DD 5E 08      [19]  101 	LD	E, 8(IX) ; DE --> Adresse image source.
   004E DD 56 09      [19]  102 	LD	D, 9(IX)
   0051                     103 	    _loop_alto001:
   0051 C5            [11]  104 	PUSH	BC ; Sauvegarde de BC sur la pile (width et height)
   0052 41            [ 4]  105 	LD	B,C ; Charge C (width) dans B
   0053 E5            [11]  106 	PUSH	HL ; Sauvegarde de HL (adresse de la destination)
   0054                     107 	    _loop_ancho001:
   0054 1A            [ 7]  108 	LD	A,(DE) ; Met dans A un octet de de la source
   0055 B6            [ 7]  109 	OR	A,(HL) ; OR A un octet de de la destination
   0056 77            [ 7]  110 	LD	(HL),A ; Met dans la destination A
   0057 13            [ 6]  111 	INC	DE ; Avance dans l'adresse de la source
   0058 23            [ 6]  112 	INC	HL ; Avance dans l'adresse de la destination
   0059 10 F9         [13]  113 	DJNZ	_loop_ancho001 ; Décrémente B qui contient la largeur. Si on à pas finit de copier
                            114 ;	l'équivalent de la largeur on saute à _loop_ancho.
   005B E1            [10]  115 	POP	HL ; récupère l'adresse de la cible sauvegardé sur la pile
   005C 7C            [ 4]  116 	LD	A,H ; Charge la partie haute dans A
   005D C6 08         [ 7]  117 	ADD	#0x08 ; Ajoute la valeur 8 à A --> Permet de passer à la ligne suivante
   005F 67            [ 4]  118 	LD	H,A ; Réinjecte A dans H, HL nous donne ainsi l'adresse de début de la ligne suivante
   0060 D6 C0         [ 7]  119 	SUB	#0xC0 ; On vérifie que la ligne suivante en mémoire n'est pas à remonter ... 
   0062 D2r69r00      [10]  120 	JP	NC, _sig_linea001 ; Non, elle est à la suite en mémoire donc tout va bien
   0065 01 50 C0      [10]  121 	LD	BC, #0xC050 ; On doit remonter, on va ajouter C000 (notre page par défaut + 0x080 pour la ligne suivante)
   0068 09            [11]  122 	ADD	HL,BC ; Ajoute ça dans l'adresse de destination --> On est sur la nouvelle ligne
   0069                     123 	    _sig_linea001:
   0069 C1            [10]  124 	POP	BC ; Récupère BC --> pour récupérer la hauteur
   006A 10 E5         [13]  125 	DJNZ	_loop_alto001 ; Enlève 1 à la hauteur, si on à pas tout traité, on reboucle au début _loop_alto
   006C DD E1         [14]  126 	pop	ix
   006E C9            [10]  127 	ret
                            128 ;jdvapi_frame.c:73: void erase_frame(unsigned char *pAddress, unsigned char nWidth, unsigned char nHeight)
                            129 ;	---------------------------------
                            130 ; Function erase_frame
                            131 ; ---------------------------------
   006F                     132 _erase_frame::
   006F DD E5         [15]  133 	push	ix
   0071 DD 21 00 00   [14]  134 	ld	ix,#0
   0075 DD 39         [15]  135 	add	ix,sp
                            136 ;jdvapi_frame.c:101: __endasm;
   0077 DD 6E 04      [19]  137 	LD	L, 4(IX) ; HL --> Adr destination
   007A DD 66 05      [19]  138 	LD	H, 5(IX)
   007D DD 4E 06      [19]  139 	LD	C, 6(IX) ; C --> Largeur en octet
   0080 DD 46 07      [19]  140 	LD	B, 7(IX) ; B --> Hauteur
   0083                     141 	    _loop_alto002:
   0083 C5            [11]  142 	PUSH	BC ; Sauvegarde de BC sur la pile (width et height)
   0084 41            [ 4]  143 	LD	B,C ; Charge C (width) dans B
   0085 E5            [11]  144 	PUSH	HL ; Sauvegarde de HL (adresse de la destination)
   0086                     145 	    _loop_ancho002:
   0086 36 00         [10]  146 	LD	(HL),#0x00 ; Met 0x00 dans la destination A
   0088 23            [ 6]  147 	INC	HL ; Avance dans l'adresse de la destination
   0089 10 FB         [13]  148 	DJNZ	_loop_ancho002 ; Décrémente B qui contient la largeur. Si on à pas finit de copier
                            149 ;	l'équivalent de la largeur on saute à _loop_ancho.
   008B E1            [10]  150 	POP	HL ; récupère l'adresse de la cible sauvegardé sur la pile
   008C 7C            [ 4]  151 	LD	A,H ; Charge la partie haute dans A
   008D C6 08         [ 7]  152 	ADD	#0x08 ; Ajoute la valeur 8 à A --> Permet de passer à la ligne suivante
   008F 67            [ 4]  153 	LD	H,A ; Réinjecte A dans H, HL nous donne ainsi l'adresse de début de la ligne suivante
   0090 D6 C0         [ 7]  154 	SUB	#0xC0 ; On vérifie que la ligne suivante en mémoire n'est pas à remonter ... 
   0092 D2r99r00      [10]  155 	JP	NC, _sig_linea002 ; Non, elle est à la suite en mémoire donc tout va bien
   0095 01 50 C0      [10]  156 	LD	BC, #0xC050 ; On doit remonter, on va ajouter C000 (notre page par défaut + 0x080 pour la ligne suivante)
   0098 09            [11]  157 	ADD	HL,BC ; Ajoute ça dans l'adresse de destination --> On est sur la nouvelle ligne
   0099                     158 	    _sig_linea002:
   0099 C1            [10]  159 	POP	BC ; Récupère BC --> pour récupérer la hauteur
   009A 10 E7         [13]  160 	DJNZ	_loop_alto002 ; Enlève 1 à la hauteur, si on à pas tout traité, on reboucle au début _loop_alto
   009C DD E1         [14]  161 	pop	ix
   009E C9            [10]  162 	ret
                            163 ;jdvapi_frame.c:109: unsigned int * precalc_vram()
                            164 ;	---------------------------------
                            165 ; Function precalc_vram
                            166 ; ---------------------------------
   009F                     167 _precalc_vram::
   009F DD E5         [15]  168 	push	ix
   00A1 DD 21 00 00   [14]  169 	ld	ix,#0
   00A5 DD 39         [15]  170 	add	ix,sp
   00A7 F5            [11]  171 	push	af
   00A8 3B            [ 6]  172 	dec	sp
                            173 ;jdvapi_frame.c:113: for (i=0;i<200;i++)
   00A9 DD 36 FD 00   [19]  174 	ld	-3 (ix),#0x00
   00AD                     175 00102$:
                            176 ;jdvapi_frame.c:115: private_precalc_vram[i]=(0xC000 + ((i / 8u) * 80u) + ((i % 8u) * 2048u));		
   00AD DD 6E FD      [19]  177 	ld	l,-3 (ix)
   00B0 26 00         [ 7]  178 	ld	h,#0x00
   00B2 29            [11]  179 	add	hl, hl
   00B3 3Er00         [ 7]  180 	ld	a,#<(_private_precalc_vram)
   00B5 85            [ 4]  181 	add	a, l
   00B6 DD 77 FE      [19]  182 	ld	-2 (ix),a
   00B9 3Es00         [ 7]  183 	ld	a,#>(_private_precalc_vram)
   00BB 8C            [ 4]  184 	adc	a, h
   00BC DD 77 FF      [19]  185 	ld	-1 (ix),a
   00BF DD 4E FD      [19]  186 	ld	c,-3 (ix)
   00C2 06 00         [ 7]  187 	ld	b,#0x00
   00C4 59            [ 4]  188 	ld	e, c
   00C5 50            [ 4]  189 	ld	d, b
   00C6 CB 3A         [ 8]  190 	srl	d
   00C8 CB 1B         [ 8]  191 	rr	e
   00CA CB 3A         [ 8]  192 	srl	d
   00CC CB 1B         [ 8]  193 	rr	e
   00CE CB 3A         [ 8]  194 	srl	d
   00D0 CB 1B         [ 8]  195 	rr	e
   00D2 6B            [ 4]  196 	ld	l, e
   00D3 62            [ 4]  197 	ld	h, d
   00D4 29            [11]  198 	add	hl, hl
   00D5 29            [11]  199 	add	hl, hl
   00D6 19            [11]  200 	add	hl, de
   00D7 29            [11]  201 	add	hl, hl
   00D8 29            [11]  202 	add	hl, hl
   00D9 29            [11]  203 	add	hl, hl
   00DA 29            [11]  204 	add	hl, hl
   00DB EB            [ 4]  205 	ex	de,hl
   00DC 21 00 C0      [10]  206 	ld	hl,#0xc000
   00DF 19            [11]  207 	add	hl,de
   00E0 EB            [ 4]  208 	ex	de,hl
   00E1 79            [ 4]  209 	ld	a,c
   00E2 E6 07         [ 7]  210 	and	a, #0x07
   00E4 07            [ 4]  211 	rlca
   00E5 07            [ 4]  212 	rlca
   00E6 07            [ 4]  213 	rlca
   00E7 E6 F8         [ 7]  214 	and	a,#0xf8
   00E9 67            [ 4]  215 	ld	h,a
   00EA 2E 00         [ 7]  216 	ld	l,#0x00
   00EC 7B            [ 4]  217 	ld	a,e
   00ED 85            [ 4]  218 	add	a, l
   00EE 5F            [ 4]  219 	ld	e,a
   00EF 7A            [ 4]  220 	ld	a,d
   00F0 8C            [ 4]  221 	adc	a, h
   00F1 57            [ 4]  222 	ld	d,a
   00F2 DD 6E FE      [19]  223 	ld	l,-2 (ix)
   00F5 DD 66 FF      [19]  224 	ld	h,-1 (ix)
   00F8 73            [ 7]  225 	ld	(hl),e
   00F9 23            [ 6]  226 	inc	hl
   00FA 72            [ 7]  227 	ld	(hl),d
                            228 ;jdvapi_frame.c:113: for (i=0;i<200;i++)
   00FB DD 34 FD      [23]  229 	inc	-3 (ix)
   00FE DD 7E FD      [19]  230 	ld	a,-3 (ix)
   0101 D6 C8         [ 7]  231 	sub	a, #0xc8
   0103 38 A8         [12]  232 	jr	C,00102$
                            233 ;jdvapi_frame.c:119: return (unsigned int *)private_precalc_vram;
   0105 21r00r00      [10]  234 	ld	hl,#_private_precalc_vram
   0108 DD F9         [10]  235 	ld	sp, ix
   010A DD E1         [14]  236 	pop	ix
   010C C9            [10]  237 	ret
                            238 	.area _CODE
                            239 	.area _INITIALIZER
                            240 	.area _CABS (ABS)
